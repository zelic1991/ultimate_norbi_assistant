# main.py
# FastAPI-Miniserver für deinen Code-Assistant: health, version, preview
from __future__ import annotations
from fastapi import FastAPI
from pydantic import BaseModel
from pathlib import Path
import datetime as dt
import difflib

APP_VERSION = "0.1.0"
ROOT = Path(__file__).resolve().parent
PREVIEWS_DIR = ROOT / "PREVIEWS"
PREVIEWS_DIR.mkdir(parents=True, exist_ok=True)

app = FastAPI(title="botfarm_controller")


# --- Models ---
class PreviewReq(BaseModel):
    spec_text: str
    target: str = "main.py"
    lang: str = "py"


# --- Helpers ---
def _generate_code(spec_text: str) -> str:
    """
    Sehr einfache Heuristik: erzeugt FastAPI-Skelett.
    - Immer: /health
    - Immer: /version (weil du das brauchst)
    (Optional könntest du hier später die spec_text-Analyse ausbauen.)
    """
    return (
        "# Generated from spec\n"
        "from fastapi import FastAPI\n\n"
        'app = FastAPI(title="generated_module")\n\n'
        '@app.get("/health")\n'
        "def health():\n"
        '    return {"ok": True}\n\n'
        f'@app.get("/version")\n'
        f"def version():\n"
        f'    return {{"version": "{APP_VERSION}"}}\n'
    )


def _count_diff(old_text: str, new_text: str) -> tuple[int, int]:
    nd = list(
        difflib.ndiff(
            old_text.splitlines(keepends=False), new_text.splitlines(keepends=False)
        )
    )
    adds = sum(1 for l in nd if l.startswith("+ "))
    rems = sum(1 for l in nd if l.startswith("- "))
    return adds, rems


# --- Routes ---
@app.get("/health")
def health():
    return {"ok": True}


@app.get("/version")
def version():
    return {"version": APP_VERSION}


@app.post("/preview")
def preview(req: PreviewReq):
    code = _generate_code(req.spec_text)

    # Ziel & Preview-Pfad
    target_path = (ROOT / req.target).resolve()
    ts = dt.datetime.now().strftime("%Y%m%d_%H%M%S")
    preview_path = PREVIEWS_DIR / f"spec_{ts}.{req.lang}"

    # Diff zählen gegen bestehendes Target (falls vorhanden)
    old_text = ""
    if target_path.exists():
        try:
            old_text = target_path.read_text(encoding="utf-8")
        except Exception:
            old_text = ""
    adds, rems = _count_diff(old_text, code)

    # Preview schreiben
    preview_path.write_text(code, encoding="utf-8")

    return {
        "preview_path": str(preview_path),
        "target": str(target_path),
        "adds": adds,
        "rems": rems,
        "note": "Preview geschrieben. Zum Übernehmen später apply_preview.ps1 nutzen.",
    }


# (Optionaler Direktrun – du startest ohnehin mit VS Code Task/uvicorn)
if __name__ == "__main__":
    import uvicorn

    uvicorn.run("main:app", host="127.0.0.1", port=8000, reload=True)
